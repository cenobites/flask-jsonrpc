# Copyright (c) 2020-2025, Cenobit Technologies, Inc. http://cenobit.es/
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# * Neither the name of the Cenobit Technologies nor the names of
#    its contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

import sys
from enum import Enum, IntEnum
from types import GeneratorType
import typing as t
import decimal
import inspect
from numbers import Number as NumberType
import builtins
from collections import OrderedDict, deque, defaultdict
import dataclasses
from collections.abc import Set, Mapping, Sequence, Collection, MutableSet, MutableMapping, MutableSequence

import typing_inspect

# Added in version 3.11.
from typing_extensions import Self, Buffer

from pydantic.main import BaseModel
from pydantic.fields import FieldInfo

from flask_jsonrpc.utils import mypyc_attr
from flask_jsonrpc.types.params import Err, Properties, BaseAnnotatedMetadata

if sys.version_info < (3, 11):

    class StrEnum(str, Enum):
        pass
else:  # pragma: no cover
    from enum import StrEnum


SLOTS = {'slots': True}


@dataclasses.dataclass(frozen=True, **SLOTS)
class AnnotatedMetadataAutoGenerated:
    auto_generated: bool = True


@mypyc_attr(native_class=False)
class AnnotatedMetadataTypeError(TypeError):
    def __init__(
        self: Self,
        annotated: BaseAnnotatedMetadata,
        name: str,
        value: t.Any,  # noqa: ANN401
        message: str,
    ) -> None:
        self.annotated = annotated
        self.name = name
        self.value = value
        self.message = message
        super().__init__(message)


def type_checker(view_func: t.Callable[..., t.Any], params: dict[str, t.Any]) -> dict[str, t.Any]:
    """
    Check the types of parameters for a given view function based on its annotations.

    Args:
        view_func (typing.Callable[..., typing.Any]): The view function to check.
        params (dict[str, typing.Any]): The parameters to check.

    Returns:
        dict[str, typing.Any]: The checked parameters.
    """
    fn_annotations = getattr(view_func, 'jsonrpc_method_params', {})
    for param_name, param_type in fn_annotations.items():
        metadata: tuple[t.Any, ...] = getattr(param_type, '__metadata__', ())
        param_value = type_metadata_checker(metadata, param_name, params.get(param_name))
        params[param_name] = param_value
    return params


def type_metadata_checker(metadata: tuple[t.Any, ...], name: str, value: t.Any) -> t.Any:  # noqa: ANN401
    """
    Check the metadata constraints for a given parameter.

    Args:
        metadata (tuple[typing.Any, ...]): The metadata to check.
        name (str): The name of the parameter.
        value (typing.Any): The value of the parameter.

    Returns:
        typing.Any: The checked value.

    Raises:
        AnnotatedMetadataTypeError: If the value does not satisfy the metadata constraints.
    """
    for mt in metadata:
        if not isinstance(mt, BaseAnnotatedMetadata):
            continue
        try:
            result = mt.type_check(name, value)
            if isinstance(result, Err):
                raise AnnotatedMetadataTypeError(
                    mt,
                    name,
                    value,
                    result.message
                    or (
                        f'ensure the value of the parameter {name!r} follows the'
                        f' {mt.__class__.__name__} constraint rules for value {value}'
                    ),
                ) from None
            value = result.value
        except TypeError as e:
            raise AnnotatedMetadataTypeError(
                mt,
                name,
                value,
                (
                    f'cannot apply constraint {mt.__class__.__name__}'
                    f' for parameter {name!r} to value {value} with type {type(value)}: {e}.'
                ),
            ) from e
    return value


def to_dict(obj: t.Any, *, level: int = 0, max_level: int = 5) -> t.Any:  # noqa: ANN401, C901
    """Convert a type annotation to a dictionary representation.

    If the maximum recursion level is reached, the type annotation is wrapped
    in an Annotated type with AnnotatedMetadataAutoGenerated.

    Args:
        obj (typing.Any): The type annotation to convert.
        level (int): The current recursion level.
        max_level (int): The maximum recursion level.

    Returns:
        typing.Any: The dictionary representation of the type annotation.

    Examples:
        >>> to_dict(list[int])
        [typing.Annotated[int, AnnotatedMetadataAutoGenerated(auto_generated=True)]]
        >>> to_dict(dict[str, float])
        typing.Annotated[dict[str, float], AnnotatedMetadataAutoGenerated(auto_generated=True)]
    """
    if isinstance(obj, dict):
        proped_dict = {}
        for key, value in obj.items():
            proped_dict[key] = to_dict(value, level=level, max_level=max_level)
        return proped_dict

    if isinstance(obj, list | set | frozenset | GeneratorType | tuple | deque):
        proped_list = []
        for item in obj:
            proped_list.append(to_dict(item, level=level, max_level=max_level))
        return proped_list

    # XXX: The only type of union that is supported is: typing.Union[T, None] or typing.Optional[T]
    if typing_inspect.is_union_type(obj):
        list_args = t.get_args(obj)
        return to_dict(list_args[0], level=level, max_level=max_level)

    if inspect.isgeneratorfunction(obj) and hasattr(obj, '__annotations__'):
        annotations = obj.__annotations__
        return to_dict(annotations['return'].__args__, level=level, max_level=max_level)

    if isinstance(obj, FieldInfo):
        if level >= max_level:
            return t.Annotated[obj.annotation, AnnotatedMetadataAutoGenerated()]
        return to_dict(obj.annotation, level=level + 1, max_level=max_level)

    if inspect.isclass(obj):
        # XXX: typing.NamedTuple
        if issubclass(obj, tuple) and not typing_inspect.is_tuple_type(obj):
            annotations = obj.__annotations__
            return to_dict(annotations, level=level, max_level=max_level)

        if dataclasses.is_dataclass(obj):
            return to_dict(obj.__annotations__, level=level, max_level=max_level)

        if issubclass(obj, Enum):
            if issubclass(obj, StrEnum):  # pragma: no cover
                return t.Annotated[str, AnnotatedMetadataAutoGenerated()]
            if issubclass(obj, IntEnum):
                return t.Annotated[int, AnnotatedMetadataAutoGenerated()]
            return t.Annotated[t.Any, AnnotatedMetadataAutoGenerated()]

        if not typing_inspect.is_generic_type(obj) and issubclass(obj, BaseModel):
            proped_dict = {}
            for name, field_info in (obj.model_fields or {}).items():
                proped_dict[name] = to_dict(field_info, level=level, max_level=max_level)
            return proped_dict

        if (
            not inspect.isbuiltin(obj)
            and getattr(obj, '__module__', '') != 'builtins'
            and hasattr(obj, '__init__')
            and hasattr(obj.__init__, '__annotations__')
        ):
            annotations = obj.__init__.__annotations__
            annotations.pop('cls', None)
            annotations.pop('self', None)
            annotations.pop('return', None)
            return to_dict(annotations, level=0, max_level=max_level)

    origin_type = t.get_origin(obj)
    if origin_type is t.Annotated:
        annotated_origin_type = getattr(obj, '__origin__', type(None))
        return to_dict(annotated_origin_type, level=level, max_level=max_level)

    if Object.check_type(origin_type):
        kv_args = t.get_args(obj)
        if isinstance(kv_args[1], type) and kv_args[1] in vars(builtins).values():
            return t.Annotated[obj, AnnotatedMetadataAutoGenerated()]
        type_found = ([tp.name for tp in Types if tp.check_type(kv_args[0])] or ['Any'])[0]
        return {f'<JSONRPCType:{type_found}>': to_dict(kv_args[1], level=level, max_level=max_level)}

    if Array.check_type(origin_type):
        list_args = t.get_args(obj)
        return to_dict(list_args, level=level, max_level=max_level)

    if hasattr(obj, '__annotations__') and getattr(obj, '__annotations__', None):
        annotations = obj.__annotations__
        return to_dict(annotations, level=level, max_level=max_level)

    return t.Annotated[obj, AnnotatedMetadataAutoGenerated()]


def propertify(obj: t.Any, *, level: int = 0, max_level: int = 5) -> t.Any:  # noqa: ANN401, C901
    """Convert a type annotation to a Properties representation.

    Args:
        obj (typing.Any): The type annotation to convert.
        level (int): The current recursion level.
        max_level (int): The maximum recursion level.

    Returns:
        typing.Any: The Properties representation of the type annotation.

    See Also:
        :func:`flask_jsonrpc.types.to_dict`: Convert a type annotation to a dictionary representation.
    """
    return Properties(to_dict(obj, level=level, max_level=max_level))


class JSONRPCNewType:
    """A new type for JSON-RPC type checking and representation.

    Args:
        name (str): The name of the new type.
        types (type | tuple[type | tuple[type, ...], ...]): The types that this new type represents.

    Attributes:
        name (str): The name of the new type.
        types (tuple[type | tuple[type, ...], ...]): The types that this new type represents.

    Examples:
        >>> String = JSONRPCNewType('String', str, bytes)
        >>> String.check_type(str)
        True
        >>> String.check_type(int)
        False
    """

    def __init__(self: Self, name: str, *types: type | tuple[type | tuple[type, ...], ...]) -> None:
        self.name = name
        self.types = types

    def _check_expected_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        """Check if the expected type matches any of the types in this new type.

        Args:
            expected_type (typing.Any): The expected type to check.

        Returns:
            bool: True if the expected type matches any of the types in this new type, False otherwise.
        """
        return any(expected_type is tp for tp in self.types)

    def _check_expected_types(self: Self, expected_types: t.Any) -> bool:  # noqa: ANN401
        """Check if all expected types match any of the types in this new type.

        Args:
            expected_types (typing.Any): The expected types to check.

        Returns:
            bool: True if all expected types match any of the types in this new type, False otherwise.
        """
        return all(self.check_type(expt_tp) for expt_tp in expected_types)

    def _check_type_var(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        """Check if the type variable matches any of the types in this new type.

        Args:
            expected_type (typing.Any): The type variable to check.

        Returns:
            bool: True if the type variable matches any of the types in this new type, False otherwise.
        """
        bound_type = getattr(expected_type, '__bound__', None)
        if bound_type is None:
            expected_types = getattr(expected_type, '__constraints__', None)
            if not expected_types:
                return self is Object
            return self._check_expected_types(expected_types)
        return self._check_expected_type(bound_type)

    def _check_new_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        """Check if the new type matches any of the types in this new type.

        Args:
            expected_type (typing.Any): The new type to check.

        Returns:
            bool: True if the new type matches any of the types in this new type, False otherwise.
        """
        super_type = getattr(expected_type, '__supertype__', None)
        return self._check_expected_type(super_type)

    def _check_union(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        """Check if the union type matches any of the types in this new type.

        Args:
            expected_type (typing.Any): The union type to check.

        Returns:
            bool: True if the union type matches any of the types in this new type, False otherwise.
        """
        expected_types = [expt_tp for expt_tp in t.get_args(expected_type) if expt_tp is not type(None)]  # noqa: E721
        return self._check_expected_types(expected_types)

    def _check_args_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        """Check if the argument types match any of the types in this new type.

        Args:
            expected_type (typing.Any): The argument types to check.

        Returns:
            bool: True if the argument types match any of the types in this new type, False otherwise.
        """
        args = t.get_args(expected_type)
        expected_types = [arg if inspect.isclass(arg) else type(arg) for arg in args]
        return self._check_expected_types(expected_types)

    def check_type(self: Self, o: t.Any) -> bool:  # noqa: ANN401
        """Check if the given type matches this new type.

        Args:
            o (typing.Any): The type to check.

        Returns:
            bool: True if the given type matches this new type, False otherwise.

        Examples:
            >>> String = JSONRPCNewType('String', str, bytes)
            >>> String.check_type(str)
            True
            >>> String.check_type(int)
            False
        """
        expected_type = o
        if expected_type is t.Any:
            return self is Object

        if expected_type is None or expected_type is t.NoReturn:
            expected_type = type(None)

        if typing_inspect.is_tuple_type(expected_type):
            return self is Array

        if typing_inspect.is_typevar(expected_type):
            return self._check_type_var(expected_type)

        if typing_inspect.is_new_type(expected_type) or hasattr(expected_type, '__supertype__'):
            return self._check_new_type(expected_type)

        if typing_inspect.is_union_type(expected_type):
            return self._check_union(expected_type)

        if typing_inspect.is_literal_type(expected_type):
            return self._check_args_type(expected_type)

        if typing_inspect.is_final_type(expected_type):
            return self._check_args_type(expected_type)

        origin_type = t.get_origin(expected_type)
        if origin_type is not None:
            expected_type = origin_type

        return self._check_expected_type(expected_type)

    def __str__(self: Self) -> str:
        return self.name


String = JSONRPCNewType('String', str, bytes, bytearray, memoryview, Buffer)
Number = JSONRPCNewType('Number', int, float, NumberType, decimal.Decimal)
Object = JSONRPCNewType(
    'Object',
    dict,
    t.Dict,  # noqa: UP006
    defaultdict,
    OrderedDict,
    Mapping,
    MutableMapping,
    t.NamedTuple,
)
Array = JSONRPCNewType(
    'Array',
    list,
    t.List,  # noqa: UP006
    set,
    t.Set,  # noqa: UP006
    tuple,
    t.Tuple,  # type: ignore[arg-type]  # noqa: UP006
    frozenset,
    t.FrozenSet,  # noqa: UP006
    GeneratorType,
    Sequence,
    MutableSequence,
    Set,
    MutableSet,
    Collection,
    deque,
)
Boolean = JSONRPCNewType('Boolean', bool)
Null = JSONRPCNewType('Null', type(None), t.Literal[None])  # type: ignore[arg-type]
Types = [Null, String, Number, Boolean, Array, Object]
