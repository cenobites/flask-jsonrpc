# Copyright (c) 2020-2024, Cenobit Technologies, Inc. http://cenobit.es/
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# * Neither the name of the Cenobit Technologies nor the names of
#    its contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

import sys
from enum import Enum, IntEnum
from types import GeneratorType
import typing as t
import decimal
import inspect
from numbers import Number as NumberType
import builtins
from collections import OrderedDict, deque, defaultdict
import dataclasses
from collections.abc import Set, Mapping, Sequence, Collection, MutableSet, MutableMapping, MutableSequence

import typing_inspect

# Added in version 3.11.
from typing_extensions import Self, Buffer

from pydantic.main import BaseModel
from pydantic.fields import FieldInfo

from ..utils import mypyc_attr
from .params import Err, Properties, BaseAnnotatedMetadata

if sys.version_info < (3, 11):

    class StrEnum(str, Enum):
        pass
else:  # pragma: no cover
    from enum import StrEnum


SLOTS = {'slots': True}


@dataclasses.dataclass(frozen=True, **SLOTS)
class AnnotatedMetadataAutoGenerated:
    auto_generated: bool = True


@mypyc_attr(native_class=False)
class AnnotatedMetadataTypeError(TypeError):
    def __init__(
        self: Self,
        annotated: BaseAnnotatedMetadata,
        name: str,
        value: t.Any,  # noqa: ANN401
        message: str,
    ) -> None:
        self.annotated = annotated
        self.name = name
        self.value = value
        self.message = message
        super().__init__(message)


def type_checker(view_func: t.Callable[..., t.Any], params: dict[str, t.Any]) -> dict[str, t.Any]:
    fn_annotations = getattr(view_func, 'jsonrpc_method_params', {})
    for param_name, param_type in fn_annotations.items():
        metadata: tuple[t.Any, ...] = getattr(param_type, '__metadata__', ())
        param_value = type_metadata_checker(metadata, param_name, params.get(param_name))
        params[param_name] = param_value
    return params


def type_metadata_checker(metadata: tuple[t.Any, ...], name: str, value: t.Any) -> t.Any:  # noqa: ANN401
    for mt in metadata:
        if not isinstance(mt, BaseAnnotatedMetadata):
            continue
        try:
            result = mt.type_check(name, value)
            if isinstance(result, Err):
                raise AnnotatedMetadataTypeError(
                    mt,
                    name,
                    value,
                    result.message
                    or (
                        f'Ensure the value of the parameter {name!r} follows the'
                        f' {mt.__class__.__name__} constraint rules for value {value}'
                    ),
                ) from None
            value = result.value
        except TypeError as e:
            raise AnnotatedMetadataTypeError(
                mt,
                name,
                value,
                (
                    f'Cannot apply constraint {mt.__class__.__name__}'
                    f' for parameter {name!r} to value {value} with type {type(value)}: {e}.'
                ),
            ) from e
    return value


def to_dict(obj: t.Any, *, level: int = 0, max_level: int = 5) -> t.Any:  # noqa: ANN401, C901
    if isinstance(obj, dict):
        proped_dict = {}
        for key, value in obj.items():
            proped_dict[key] = to_dict(value, level=level, max_level=max_level)
        return proped_dict

    if isinstance(obj, list | set | frozenset | GeneratorType | tuple | deque):
        proped_list = []
        for item in obj:
            proped_list.append(to_dict(item, level=level, max_level=max_level))
        return proped_list

    # XXX: The only type of union that is supported is: typing.Union[T, None] or typing.Optional[T]
    if typing_inspect.is_union_type(obj):
        list_args = t.get_args(obj)
        return to_dict(list_args[0], level=level, max_level=max_level)

    if inspect.isgeneratorfunction(obj) and hasattr(obj, '__annotations__'):
        annotations = obj.__annotations__
        return to_dict(annotations['return'].__args__, level=level, max_level=max_level)

    if isinstance(obj, FieldInfo):
        if level >= max_level:
            return t.Annotated[obj.annotation, AnnotatedMetadataAutoGenerated()]
        return to_dict(obj.annotation, level=level + 1, max_level=max_level)

    if inspect.isclass(obj):
        # XXX: typing.NamedTuple
        if issubclass(obj, tuple) and not typing_inspect.is_tuple_type(obj):
            annotations = obj.__annotations__
            return to_dict(annotations, level=level, max_level=max_level)

        if dataclasses.is_dataclass(obj):
            return to_dict(obj.__annotations__, level=level, max_level=max_level)

        if issubclass(obj, Enum):
            if issubclass(obj, StrEnum):  # pragma: no cover
                return t.Annotated[str, AnnotatedMetadataAutoGenerated()]
            if issubclass(obj, IntEnum):
                return t.Annotated[int, AnnotatedMetadataAutoGenerated()]
            return t.Annotated[t.Any, AnnotatedMetadataAutoGenerated()]

        if not typing_inspect.is_generic_type(obj) and issubclass(obj, BaseModel):
            proped_dict = {}
            for name, field_info in (obj.model_fields or {}).items():
                proped_dict[name] = to_dict(field_info, level=level, max_level=max_level)
            return proped_dict

        if (
            not inspect.isbuiltin(obj)
            and getattr(obj, '__module__', '') != 'builtins'
            and hasattr(obj, '__init__')
            and hasattr(obj.__init__, '__annotations__')
        ):
            annotations = obj.__init__.__annotations__
            annotations.pop('cls', None)
            annotations.pop('self', None)
            annotations.pop('return', None)
            return to_dict(annotations, level=0, max_level=max_level)

    origin_type = t.get_origin(obj)
    if origin_type is t.Annotated:
        annotated_origin_type = getattr(obj, '__origin__', type(None))
        return to_dict(annotated_origin_type, level=level, max_level=max_level)

    if Object.check_type(origin_type):
        kv_args = t.get_args(obj)
        if isinstance(kv_args[1], type) and kv_args[1] in vars(builtins).values():
            return t.Annotated[obj, AnnotatedMetadataAutoGenerated()]
        type_found = ([tp.name for tp in Types if tp.check_type(kv_args[0])] or ['Any'])[0]
        return {f'<JSONRPCType:{type_found}>': to_dict(kv_args[1], level=level, max_level=max_level)}

    if Array.check_type(origin_type):
        list_args = t.get_args(obj)
        return to_dict(list_args, level=level, max_level=max_level)

    if hasattr(obj, '__annotations__') and getattr(obj, '__annotations__', None):
        annotations = obj.__annotations__
        return to_dict(annotations, level=level, max_level=max_level)

    return t.Annotated[obj, AnnotatedMetadataAutoGenerated()]


def propertify(obj: t.Any, *, level: int = 0, max_level: int = 5) -> t.Any:  # noqa: ANN401, C901
    return Properties(to_dict(obj, level=level, max_level=max_level))


class JSONRPCNewType:
    def __init__(self: Self, name: str, *types: type | tuple[type | tuple[type, ...], ...]) -> None:
        self.name = name
        self.types = types

    def _check_expected_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        return any(expected_type is tp for tp in self.types)

    def _check_expected_types(self: Self, expected_types: t.Any) -> bool:  # noqa: ANN401
        return all(self.check_type(expt_tp) for expt_tp in expected_types)

    def _check_type_var(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        bound_type = getattr(expected_type, '__bound__', None)
        if bound_type is None:
            expected_types = getattr(expected_type, '__constraints__', None)
            if not expected_types:
                return self is Object
            return self._check_expected_types(expected_types)
        return self._check_expected_type(bound_type)

    def _check_new_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        super_type = getattr(expected_type, '__supertype__', None)
        return self._check_expected_type(super_type)

    def _check_union(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        expected_types = [expt_tp for expt_tp in t.get_args(expected_type) if expt_tp is not type(None)]  # noqa: E721
        return self._check_expected_types(expected_types)

    def _check_args_type(self: Self, expected_type: t.Any) -> bool:  # noqa: ANN401
        args = t.get_args(expected_type)
        expected_types = [arg if inspect.isclass(arg) else type(arg) for arg in args]
        return self._check_expected_types(expected_types)

    def check_type(self: Self, o: t.Any) -> bool:  # noqa: ANN401
        expected_type = o
        if expected_type is t.Any:
            return self is Object

        if expected_type is None or expected_type is t.NoReturn:
            expected_type = type(None)

        if typing_inspect.is_tuple_type(expected_type):
            return self is Array

        if typing_inspect.is_typevar(expected_type):
            return self._check_type_var(expected_type)

        if typing_inspect.is_new_type(expected_type) or hasattr(expected_type, '__supertype__'):
            return self._check_new_type(expected_type)

        if typing_inspect.is_union_type(expected_type):
            return self._check_union(expected_type)

        if typing_inspect.is_literal_type(expected_type):
            return self._check_args_type(expected_type)

        if typing_inspect.is_final_type(expected_type):
            return self._check_args_type(expected_type)

        origin_type = t.get_origin(expected_type)
        if origin_type is not None:
            expected_type = origin_type

        return self._check_expected_type(expected_type)

    def __str__(self: Self) -> str:
        return self.name


String = JSONRPCNewType('String', str, bytes, bytearray, memoryview, Buffer)
Number = JSONRPCNewType('Number', int, float, NumberType, decimal.Decimal)
Object = JSONRPCNewType(
    'Object',
    dict,
    t.Dict,  # noqa: UP006
    defaultdict,
    OrderedDict,
    Mapping,
    MutableMapping,
    t.NamedTuple,
)
Array = JSONRPCNewType(
    'Array',
    list,
    t.List,  # noqa: UP006
    set,
    t.Set,  # noqa: UP006
    tuple,
    t.Tuple,  # type: ignore[arg-type]  # noqa: UP006
    frozenset,
    t.FrozenSet,  # noqa: UP006
    GeneratorType,
    Sequence,
    MutableSequence,
    Set,
    MutableSet,
    Collection,
    deque,
)
Boolean = JSONRPCNewType('Boolean', bool)
Null = JSONRPCNewType('Null', type(None), t.Literal[None])  # type: ignore[arg-type]
Types = [Null, String, Number, Boolean, Array, Object]
