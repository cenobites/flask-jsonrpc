# Copyright (c) 2021-2024, Cenobit Technologies, Inc. http://cenobit.es/
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# * Neither the name of the Cenobit Technologies nor the names of
#    its contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
import sys
import typing as t
from numbers import Real, Number, Complex, Integral, Rational
from collections import OrderedDict, defaultdict
import dataclasses

from typing_extensions import Self, ReadOnly

from pydantic import BaseModel

import pytest

from flask_jsonrpc import types, typing as fjt
from flask_jsonrpc.types.params import Summary, Required, Properties


def test_type_checker() -> None:
    def sample_func(param1: str, param2: int) -> None:
        pass

    sample_func.jsonrpc_method_params = {
        'param1': Summary(summary='Summary for param1'),
        'param2': Required(required=True),
    }

    params = {'param1': 'value', 'param2': 10}

    result = types.type_checker(sample_func, params)
    assert result['param1'] == 'value'
    assert result['param2'] == 10


def test_type_checker_with_not_compliant_metada() -> None:
    def sample_func(param1: str, param2: int) -> None:
        pass

    sample_func.jsonrpc_method_params = {'param1': ReadOnly, 'param2': Required(required=True)}

    params = {'param1': 'value', 'param2': 10}

    result = types.type_checker(sample_func, params)
    assert result['param1'] == 'value'
    assert result['param2'] == 10


def test_type_metadata_checker() -> None:
    required = Required()
    assert types.type_metadata_checker((required,), 'param', 'value') == 'value'
    with pytest.raises(types.AnnotatedMetadataTypeError) as excinfo:
        types.type_metadata_checker((required,), 'param', None)
        assert excinfo.annotated == required
        assert excinfo.name == 'param'
        assert excinfo.value is None
        assert excinfo.message == "Ensure the value of the parameter 'param' is not empty"


def test_type_metadata_checker_with_not_complaint_metadata() -> None:
    assert types.type_metadata_checker((ReadOnly, Required()), 'param', 'value') == 'value'


def test_annotated_metadata_type_error() -> None:
    try:
        required = Required()
        required.type_check('param', None)
    except types.AnnotatedMetadataTypeError as e:
        assert isinstance(e, types.AnnotatedMetadataTypeError)
        assert e.message == "Ensure the value of the parameter 'param' is not empty"
        assert e.name == 'param'
        assert e.value is None


def test_to_dict_none() -> None:
    result = types.to_dict(type(None))
    expected = t.Annotated[type(None), types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_dict() -> None:
    test_dict = dict[str, str]
    result = types.to_dict(test_dict)
    expected = t.Annotated[dict[str, str], types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'

    test_dict = {'a': int, 'b': {'x': int, 'y': int}}
    result = types.to_dict(test_dict)
    expected = {
        'a': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'b': {
            'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
            'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        },
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_dict_() -> None:
    test_dict = t.Dict[str, str]  # noqa: UP006
    result = types.to_dict(test_dict)
    expected = t.Annotated[t.Dict[str, str], types.AnnotatedMetadataAutoGenerated()]  # noqa: UP006
    assert result == expected, f'Expected {expected}, got {result}'

    test_dict = {'a': int, 'b': {'x': int, 'y': int}}
    result = types.to_dict(test_dict)
    expected = {
        'a': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'b': {
            'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
            'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        },
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_list() -> None:
    test_list = list[int]
    result = types.to_dict(test_list)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'

    test_list = [int, str, {'a': int, 'b': str}]
    result = types.to_dict(test_list)
    expected = [
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        {
            'a': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
            'b': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        },
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_list_() -> None:
    test_list = t.List[int]  # noqa: UP006
    result = types.to_dict(test_list)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'

    test_list = [int, str, {'a': int, 'b': str}]
    result = types.to_dict(test_list)
    expected = [
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        {
            'a': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
            'b': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        },
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_set() -> None:
    test_set = set[int]
    result = types.to_dict(test_set)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_set_() -> None:
    test_set = t.Set[int]  # noqa: UP006
    result = types.to_dict(test_set)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_frozenset() -> None:
    test_frozenset = frozenset[int]
    result = types.to_dict(test_frozenset)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_frozenset_() -> None:
    test_frozenset = t.FrozenSet[int]  # noqa: UP006
    result = types.to_dict(test_frozenset)
    expected = [t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]]
    assert result == expected, f'Expected {expected}, got {result}'


@pytest.mark.skipif(sys.version_info < (3, 11), reason='requires python3.11 or higher')
def test_to_dict_tuple() -> None:
    test_tuple = tuple[int, int, int]
    result = types.to_dict(test_tuple)
    expected = [
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_tuple_() -> None:
    test_tuple = t.Tuple[int, int, int]  # noqa: UP006
    result = types.to_dict(test_tuple)
    expected = [
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_dataclass() -> None:
    @dataclasses.dataclass
    class MyDataClass:
        name: str
        age: int

    test_dataclass = MyDataClass
    result = types.to_dict(test_dataclass)
    expected = {
        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'age': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_pydantic_model() -> None:
    class MyModel(BaseModel):
        name: str
        age: int

    test_model = MyModel
    result = types.to_dict(test_model)
    expected = {
        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'age': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_custom_class() -> None:
    class CustomClass:
        def __init__(self: Self, x: int, y: int) -> None:
            self.x = x
            self.y = y

    test_object = CustomClass
    result = types.to_dict(test_object)
    expected = {
        'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_optional_custom_class() -> None:
    class CustomClass:
        def __init__(self: Self, x: int, y: int) -> None:
            self.x = x
            self.y = y

    test_object = t.Optional[CustomClass]
    result = types.to_dict(test_object)
    expected = {
        'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_union_custom_class() -> None:
    class CustomClass1:
        def __init__(self: Self, x: int, y: int) -> None:
            self.x = x
            self.y = y

    class CustomClass2:
        def __init__(self: Self, z: int) -> None:
            self.z = z

    test_object = t.Union[CustomClass1, None]
    result = types.to_dict(test_object)
    expected = {
        'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'

    test_object = t.Union[CustomClass1, CustomClass2]
    result = types.to_dict(test_object)
    expected = {
        'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_empty_dict() -> None:
    result = types.to_dict({})
    expected = {}
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_string() -> None:
    result = types.to_dict(str)
    expected = t.Annotated[str, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_builtin_type() -> None:
    result = types.to_dict(int)
    expected = t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_generator() -> None:
    def my_gen() -> t.Generator[int, None, None]:
        yield 1
        yield 2

    result = types.to_dict(my_gen)
    expected = [
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[type(None), types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[type(None), types.AnnotatedMetadataAutoGenerated()],
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_annotated() -> None:
    result = types.to_dict(t.Annotated[str, None])
    expected = t.Annotated[str, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_none_in_list() -> None:
    result = types.to_dict([type(None), int, int])
    expected = [
        t.Annotated[type(None), types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    ]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_field_info() -> None:
    from pydantic import Field

    field_info = Field(None, description='A test field')
    result = types.to_dict(field_info)
    expected = t.Annotated[None, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_enum() -> None:
    from enum import Enum

    class MyEnum(Enum):
        A = 1
        B = 2

    result = types.to_dict(MyEnum)
    expected = t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


@pytest.mark.skipif(sys.version_info < (3, 11), reason='requires python3.11 or higher')
def test_to_dict_str_enum() -> None:
    from enum import StrEnum

    class MyEnum(StrEnum):
        A = 'a'
        B = 'b'

    result = types.to_dict(MyEnum)
    expected = t.Annotated[str, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_int_enum() -> None:
    from enum import IntEnum

    class MyEnum(IntEnum):
        A = 1
        B = 2

    result = types.to_dict(MyEnum)
    expected = t.Annotated[int, types.AnnotatedMetadataAutoGenerated()]
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_named_tuple() -> None:
    from typing import NamedTuple

    class MyNamedTuple(NamedTuple):
        name: str
        age: int

    result = types.to_dict(MyNamedTuple)
    expected = {
        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'age': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_typeddict() -> None:
    from typing import TypedDict

    class MyTypedDict(TypedDict):
        name: str
        age: int

    result = types.to_dict(MyTypedDict)
    expected = {
        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'age': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_to_dict_with_complex_object() -> None:
    result = types.to_dict(fjt.ServiceDescribe)
    expected = {
        'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'id': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'methods': {
            '<JSONRPCType:String>': {
                'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                'errors': [
                    {
                        'code': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                        'data': t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()],
                        'message': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'status_code': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                    }
                ],
                'examples': [
                    {
                        'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'params': [
                            {
                                'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'value': t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()],
                            }
                        ],
                        'returns': {
                            'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'value': t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()],
                        },
                        'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    }
                ],
                'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                'notification': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                'params': [
                    {
                        'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                        'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                        'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                        'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                        'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                        'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                        'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                        'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                        'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                        'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                        'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'properties': {
                            '<JSONRPCType:String>': {
                                'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                                'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'properties': {
                                    '<JSONRPCType:String>': {
                                        'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                        'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                        'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                        'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                        'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                                        'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                        'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                        'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                        'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                        'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                        'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                        'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                        'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                        'properties': {
                                            '<JSONRPCType:String>': {
                                                'allow_inf_nan': t.Annotated[
                                                    t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'decimal_places': t.Annotated[
                                                    t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'deprecated': t.Annotated[
                                                    t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'description': t.Annotated[
                                                    t.Optional[str], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'examples': t.Annotated[
                                                    t.Optional[list[t.Any]], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'max_digits': t.Annotated[
                                                    t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'max_length': t.Annotated[
                                                    t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'maximum': t.Annotated[
                                                    t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'min_length': t.Annotated[
                                                    t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'minimum': t.Annotated[
                                                    t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'multiple_of': t.Annotated[
                                                    t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                                'nullable': t.Annotated[
                                                    t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'pattern': t.Annotated[
                                                    t.Union[str, t.Pattern[str], type(None)],
                                                    types.AnnotatedMetadataAutoGenerated(),
                                                ],
                                                'properties': t.Annotated[
                                                    t.Optional[t.Mapping[str, fjt.Field]],
                                                    types.AnnotatedMetadataAutoGenerated(),
                                                ],
                                                'required': t.Annotated[
                                                    t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'summary': t.Annotated[
                                                    t.Optional[str], types.AnnotatedMetadataAutoGenerated()
                                                ],
                                                'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                            }
                                        },
                                        'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                        'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                        'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                    }
                                },
                                'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            }
                        },
                        'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                        'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    }
                ],
                'returns': {
                    'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                    'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                    'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                    'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                    'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                    'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                    'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                    'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                    'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                    'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                    'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                    'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    'properties': {
                        '<JSONRPCType:String>': {
                            'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                            'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                            'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                            'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                            'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                            'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                            'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                            'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                            'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                            'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                            'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                            'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'properties': {
                                '<JSONRPCType:String>': {
                                    'allow_inf_nan': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                    'decimal_places': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                    'deprecated': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                    'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                    'examples': [t.Annotated[t.Any, types.AnnotatedMetadataAutoGenerated()]],
                                    'max_digits': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                    'max_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                    'maximum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                    'min_length': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
                                    'minimum': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                    'multiple_of': t.Annotated[float, types.AnnotatedMetadataAutoGenerated()],
                                    'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                    'nullable': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                    'pattern': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                    'properties': {
                                        '<JSONRPCType:String>': {
                                            'allow_inf_nan': t.Annotated[
                                                t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'decimal_places': t.Annotated[
                                                t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'deprecated': t.Annotated[
                                                t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'description': t.Annotated[
                                                t.Optional[str], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'examples': t.Annotated[
                                                t.Optional[list[t.Any]], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'max_digits': t.Annotated[
                                                t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'max_length': t.Annotated[
                                                t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'maximum': t.Annotated[
                                                t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'min_length': t.Annotated[
                                                t.Optional[int], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'minimum': t.Annotated[
                                                t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'multiple_of': t.Annotated[
                                                t.Optional[float], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                            'nullable': t.Annotated[
                                                t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'pattern': t.Annotated[
                                                t.Union[str, t.Pattern[str], type(None)],
                                                types.AnnotatedMetadataAutoGenerated(),
                                            ],
                                            'properties': t.Annotated[
                                                t.Optional[t.Mapping[str, fjt.Field]],
                                                types.AnnotatedMetadataAutoGenerated(),
                                            ],
                                            'required': t.Annotated[
                                                t.Optional[bool], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'summary': t.Annotated[
                                                t.Optional[str], types.AnnotatedMetadataAutoGenerated()
                                            ],
                                            'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                        }
                                    },
                                    'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                                    'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                    'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                                }
                            },
                            'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                            'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                            'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                        }
                    },
                    'required': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
                    'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                    'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                },
                'summary': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                'tags': [t.Annotated[str, types.AnnotatedMetadataAutoGenerated()]],
                'type': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                'validation': t.Annotated[bool, types.AnnotatedMetadataAutoGenerated()],
            }
        },
        'name': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'servers': [
            {
                'description': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
                'url': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
            }
        ],
        'title': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
        'version': t.Annotated[str, types.AnnotatedMetadataAutoGenerated()],
    }
    assert result == expected, f'Expected {expected}, got {result}'


def test_propertify_custom_class() -> None:
    class CustomClass:
        def __init__(self: Self, x: int, y: int) -> None:
            self.x = x
            self.y = y

    test_object = CustomClass
    result = types.propertify(test_object)
    expected = Properties(
        {
            'x': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
            'y': t.Annotated[int, types.AnnotatedMetadataAutoGenerated()],
        }
    )
    assert result == expected, f'Expected {expected}, got {result}'


def test_types_empty_type() -> None:
    empty_type = types.JSONRPCNewType('Empty', ())
    assert not empty_type.check_type(str)


def test_types_string() -> None:
    assert types.String.check_type(str)
    assert types.String.check_type(t.AnyStr)
    assert str(types.String) == 'String'


def test_types_number() -> None:
    assert types.Number.check_type(int)
    assert types.Number.check_type(float)
    assert not types.Number.check_type(complex)
    assert not types.Number.check_type(Real)
    assert not types.Number.check_type(Rational)
    assert not types.Number.check_type(Integral)
    assert not types.Number.check_type(Complex)
    assert types.Number.check_type(Number)
    assert str(types.Number) == 'Number'


def test_types_object() -> None:
    assert types.Object.check_type(dict)
    assert types.Object.check_type(dict)
    assert types.Object.check_type(t.Any)
    assert str(types.Object) == 'Object'


def test_types_array() -> None:
    assert types.Array.check_type(list)
    assert types.Array.check_type(tuple)
    assert types.Array.check_type(set)
    assert types.Array.check_type(list)
    assert types.Array.check_type(set)
    assert types.Array.check_type(tuple)
    assert types.Array.check_type(frozenset)
    assert types.Array.check_type(frozenset)
    assert str(types.Array) == 'Array'


def test_types_boolean() -> None:
    assert types.Boolean.check_type(bool)
    assert str(types.Boolean) == 'Boolean'


def test_types_null() -> None:
    assert types.Null.check_type(None)
    assert types.Null.check_type(type(None))  # noqa: E721
    assert types.Null.check_type(t.NoReturn)
    assert types.Null.check_type(t.Literal[None])
    assert not types.Object.check_type(t.Literal[None])
    assert str(types.Null) == 'Null'


def test_types_python_mapping() -> None:
    assert types.Object.check_type(OrderedDict)
    assert types.Object.check_type(defaultdict)
    assert types.Object.check_type(defaultdict)
    assert types.Object.check_type(t.Mapping)


def test_types_type_var() -> None:
    T = t.TypeVar('T')
    S = t.TypeVar('S', int, float)
    X = t.TypeVar('X', bound=int)

    assert types.Object.check_type(T)
    assert types.Number.check_type(S)
    assert types.Number.check_type(X)


def test_types_literal() -> None:
    assert types.String.check_type(t.Literal[str])
    assert types.String.check_type(t.Literal['hello', 'world'])
    assert not types.String.check_type(t.Literal[1, 2])


def test_types_final() -> None:
    assert types.String.check_type(t.Final[str])
    assert not types.String.check_type(t.Final[int])


def test_types_union() -> None:
    class CustomClass1:
        pass

    class CustomClass2:
        pass

    assert types.String.check_type(t.Union[str, None])
    assert types.String.check_type(t.Optional[str])
    assert not types.String.check_type(t.Union[str, int])
    assert not types.Number.check_type(t.Union[str, int])
    assert types.Object.check_type(t.Union[dict[str, str], None])
    assert types.Object.check_type(t.Optional[dict[int, int]])
    assert not types.Object.check_type(t.Optional[None])
    assert not types.Object.check_type(t.Union[None])
    assert not types.Object.check_type(t.Union[CustomClass1, CustomClass2])


def test_types_custom_type() -> None:
    class CustomType:
        __supertype__ = str

    custom_type = types.JSONRPCNewType('CustomType', str)
    assert custom_type.check_type(CustomType())


def test_types_from_fn() -> None:
    def fn(_a: str, _b: int, _c: dict[str, t.Any], _d: list[int], _e: t.Any) -> bool:  # noqa: ANN401
        return True

    fn_annotations = t.get_type_hints(fn)
    assert types.String.check_type(fn_annotations['_a'])
    assert types.Number.check_type(fn_annotations['_b'])
    assert types.Object.check_type(fn_annotations['_c'])
    assert types.Array.check_type(fn_annotations['_d'])
    assert types.Object.check_type(fn_annotations['_e'])
    assert types.Boolean.check_type(fn_annotations['return'])


@pytest.mark.skipif(sys.version_info < (3, 9), reason='requires python3.9 or higher')
def test_types_generic_type_alias() -> None:
    T = t.TypeVar('T')

    assert types.Array.check_type(list[int])
    assert types.Array.check_type(list[float])
    assert types.Array.check_type(set[str])
    assert types.Array.check_type(frozenset[int])
    assert types.Array.check_type(tuple[int])
    assert types.Object.check_type(dict[int, str])
    assert types.Object.check_type(dict[int, T][str])  # type: ignore
    assert types.Object.check_type(dict[int, list[int]])


@pytest.mark.skipif(sys.version_info < (3, 10), reason='requires python3.10 or higher')
def test_types_union_type_expression() -> None:
    assert types.Array.check_type(list[int | str])
    assert types.String.check_type(str | bytearray)
    assert types.String.check_type(bytearray | str)
    assert types.String.check_type(str)
    assert types.Number.check_type(int | float)


@pytest.mark.skipif(sys.version_info < (3, 10), reason='requires python3.10 or higher')
def test_types_none_type() -> None:
    assert types.Null.check_type(type(None))


def test_types_new_type() -> None:
    UserId = t.NewType('UserId', int)
    UserUid = t.NewType('UserUid', str)

    assert types.Number.check_type(UserId)
    assert types.String.check_type(UserUid)
    assert not types.Number.check_type(UserUid)
